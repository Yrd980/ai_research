<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Noun Graph</title>
  <style>
    :root {
      --bg1: #eef3ff;
      --bg2: #dbe9f3;
      --line: #d5def4;
    }
    * { box-sizing: border-box; }
    html, body {
      margin: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background:
        radial-gradient(circle at 10% 10%, rgba(15, 76, 129, 0.16), transparent 28%),
        radial-gradient(circle at 85% 15%, rgba(10, 124, 102, 0.18), transparent 26%),
        linear-gradient(160deg, var(--bg1), var(--bg2));
      font-family: "Segoe UI", "PingFang SC", "Noto Sans CJK SC", sans-serif;
    }
    #graph {
      width: 100vw;
      height: 100vh;
      border: 0;
    }
  </style>
</head>
<body>
  <div id="graph"></div>

  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
  <script src="https://unpkg.com/vis-network@9.1.9/standalone/umd/vis-network.min.js"></script>
  <script src="./graph_data.js"></script>
  <script>
    const graphEl = document.getElementById("graph");
    const TERMS_PATH = "../wiki/index/terms.csv";
    const EDGES_PATH = "../wiki/index/term_edges.csv";

    const colorByType = {
      Company: "#0284c7",
      Person: "#f97316",
      Product: "#7c3aed",
      Model: "#0f766e",
      Technique: "#b45309",
      Concept: "#475569",
      Framework: "#0ea5e9",
      Platform: "#16a34a",
      Project: "#dc2626",
      Standard: "#334155",
      Metric: "#6d28d9",
      Flag: "#e11d48",
      Unknown: "#6b7280"
    };

    function parseCsvText(text) {
      return new Promise((resolve, reject) => {
        Papa.parse(text, {
          header: true,
          skipEmptyLines: true,
          complete: (results) => resolve(results.data),
          error: (err) => reject(err)
        });
      });
    }

    async function loadCsvFromPath(path) {
      try {
        const res = await fetch(path, { cache: "no-store" });
        if (!res.ok) throw new Error(path);
        return await parseCsvText(await res.text());
      } catch (_) {
        return null;
      }
    }

    function degreeMap(edgeRows) {
      const map = new Map();
      for (const e of edgeRows) {
        const w = Number(e.cooccurrence_count || 0) || 1;
        map.set(e.term_id_a, (map.get(e.term_id_a) || 0) + w);
        map.set(e.term_id_b, (map.get(e.term_id_b) || 0) + w);
      }
      return map;
    }

    async function render() {
      const csvTerms = await loadCsvFromPath(TERMS_PATH);
      const csvEdges = await loadCsvFromPath(EDGES_PATH);
      const termRows = csvTerms || window.GRAPH_DATA?.terms || [];
      const edgeRowsRaw = csvEdges || window.GRAPH_DATA?.edges || [];

      const focusTypes = new Set(["Company", "Product", "Model", "Person", "Platform", "Framework"]);
      const termRowsFiltered = termRows.filter((t) => focusTypes.has(t.term_type || "Unknown"));
      const termById = new Map(termRowsFiltered.map((t) => [t.term_id, t]));
      const edgeRows = edgeRowsRaw.filter((e) => termById.has(e.term_id_a) && termById.has(e.term_id_b));

      const degrees = degreeMap(edgeRows);
      const ranked = [...termRowsFiltered].sort((a, b) => (degrees.get(b.term_id) || 0) - (degrees.get(a.term_id) || 0));
      const topNodeIds = new Set(ranked.slice(0, 450).map((r) => r.term_id));
      const finalEdges = edgeRows.filter((e) => topNodeIds.has(e.term_id_a) && topNodeIds.has(e.term_id_b));

      const activeIds = new Set();
      for (const e of finalEdges) {
        activeIds.add(e.term_id_a);
        activeIds.add(e.term_id_b);
      }

      const nodes = [];
      for (const t of termRowsFiltered) {
        if (!activeIds.has(t.term_id)) continue;
        const deg = degrees.get(t.term_id) || 0;
        const size = 12 + Math.min(8, Math.log2(deg + 1) * 1.6);
        const type = t.term_type || "Unknown";
        nodes.push({
          id: t.term_id,
          label: t.term,
          title: `${t.term}\n${type}`,
          size,
          color: colorByType[type] || colorByType.Unknown,
          font: { size: 13 }
        });
      }

      const edges = finalEdges.map((e) => ({
        from: e.term_id_a,
        to: e.term_id_b,
        width: 0.9,
        color: { color: "rgba(70, 92, 127, 0.16)", highlight: "#2f5f93" },
        title: `${e.term_a} â†” ${e.term_b}`
      }));

      new vis.Network(graphEl, { nodes: new vis.DataSet(nodes), edges: new vis.DataSet(edges) }, {
        autoResize: true,
        interaction: {
          hover: true,
          tooltipDelay: 120,
          dragNodes: true,
          dragView: true,
          zoomView: true,
          navigationButtons: false,
          keyboard: true
        },
        physics: {
          enabled: true,
          solver: "forceAtlas2Based",
          forceAtlas2Based: {
            gravitationalConstant: -28,
            centralGravity: 0.006,
            springLength: 92,
            springConstant: 0.06,
            damping: 0.6
          },
          stabilization: { enabled: true, iterations: 420 }
        },
        nodes: {
          shape: "dot",
          borderWidth: 0,
          borderWidthSelected: 1
        },
        edges: {
          smooth: { enabled: true, type: "continuous", roundness: 0.08 },
          selectionWidth: 1.1
        }
      });
    }

    render();
  </script>
</body>
</html>
